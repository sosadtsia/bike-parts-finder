---
description: Svelte Development Standards
globs: web/frontend/**
alwaysApply: false
---

# Svelte Development Standards

## Component Structure

### File Organization

Each Svelte component should follow this structure:

```svelte
<script>
  // Imports first
  import { onMount } from 'svelte';
  import ChildComponent from './ChildComponent.svelte';

  // Props
  export let propName = defaultValue;

  // Local state
  let count = 0;

  // Reactive declarations
  $: doubled = count * 2;

  // Lifecycle hooks
  onMount(() => {
    // Component mounted logic
    return () => {
      // Cleanup logic
    };
  });

  // Event handlers
  function handleClick() {
    count += 1;
  }
</script>

<style>
  /* Component-scoped CSS */
  div {
    color: var(--text-color);
  }
</style>

<!-- Markup last -->
<div>
  <h1>Count: {count}</h1>
  <button on:click={handleClick}>Increment</button>
  <ChildComponent prop={value} />
</div>
```

### Project Organization

1. **Directory Structure**:
   - `src/routes/` - SvelteKit pages/routes
   - `src/lib/` - Reusable components and utilities
   - `src/stores/` - Svelte stores
   - `static/` - Static assets

2. **Naming Conventions**:
   - Component files: PascalCase (e.g., `Button.svelte`)
   - Utility files: camelCase (e.g., `formatDate.js`)
   - Store files: camelCase (e.g., `userStore.js`)

## State Management

### Component State

Use local variables for component-specific state:

```svelte
<script>
  let count = 0;

  function increment() {
    count += 1;
  }
</script>
```

### Reactive Declarations

Use reactive declarations for derived state:

```svelte
<script>
  let count = 0;
  $: doubled = count * 2;
  $: if (count > 10) {
    alert('Count is getting high!');
  }
</script>
```

### Svelte Stores

Use stores for shared state across components:

```js
// stores/count.js
import { writable } from 'svelte/store';

export const count = writable(0);
```

```svelte
<script>
  import { count } from '../stores/count';

  function increment() {
    $count += 1;
  }
</script>

<button on:click={increment}>
  Count: {$count}
</button>
```

## Props and Events

### Props

Define props with default values when appropriate:

```svelte
<script>
  export let text = 'Default text';
  export let required; // No default, implies required
</script>
```

### Events

Use event forwarding and custom events:

```svelte
<script>
  import { createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  function handleClick() {
    dispatch('custom-event', { detail: 'value' });
  }
</script>

<button on:click={handleClick} on:mouseover>
  Click me
</button>
```

## Bindings and Directives

### Two-way Binding

Use `bind:` directive for two-way data binding:

```svelte
<input bind:value={name} />
```

### Conditional Rendering

Use `{#if}`, `{:else if}`, and `{:else}` blocks:

```svelte
{#if condition}
  <p>Shown when condition is true</p>
{:else if otherCondition}
  <p>Shown when otherCondition is true</p>
{:else}
  <p>Shown otherwise</p>
{/if}
```

### Loops

Use `{#each}` blocks with unique keys:

```svelte
{#each items as item, i (item.id)}
  <div>{item.name}</div>
{:else}
  <div>No items found</div>
{/each}
```

### Await Blocks

Use `{#await}` blocks for promises:

```svelte
{#await promise}
  <p>Loading...</p>
{:then value}
  <p>The value is {value}</p>
{:catch error}
  <p>Error: {error.message}</p>
{/await}
```

## Performance Optimization

1. Use `{@const}` for values used multiple times in markup
2. Avoid unnecessary reactivity with `$:` declarations
3. Use `bind:this` sparingly
4. Implement proper cleanup in lifecycle hooks

## Styling

1. Use component-scoped styles by default
2. Use CSS custom properties for theming
3. Consider CSS preprocessors for complex styling needs

## Accessibility

1. Use semantic HTML elements
2. Add appropriate ARIA attributes when needed
3. Ensure keyboard navigation works properly
4. Test with screen readers

## SvelteKit Best Practices

1. **Routing**:
   - Use directory-based routing
   - Implement layouts for shared UI elements
   - Use route parameters for dynamic content

2. **Data Loading**:
   - Use `load` functions for data fetching
   - Implement proper error handling
   - Use `invalidate()` for refreshing data

3. **Form Handling**:
   - Use progressive enhancement with `use:enhance`
   - Validate both client-side and server-side

## Testing

1. Use Vitest or Jest for unit testing
2. Use Playwright or Cypress for end-to-end testing
3. Test components in isolation with `@testing-library/svelte`

## Additional Resources

- [Svelte Documentation](https://svelte.dev/docs)
- [SvelteKit Documentation](https://kit.svelte.dev/docs)
- [Svelte Society](https://sveltesociety.dev/)
description:
globs:
alwaysApply: false
---
